# Explain Code Command

Genera explicaciones inteligentes y did√°cticas de c√≥digo usando IA avanzada para acelerar comprensi√≥n, onboarding y reviews.

## Descripci√≥n

El comando `/explain-code` es tu profesor personal de c√≥digo que transforma c√≥digo complejo en explicaciones claras:

- **Explicaciones contextuales** adaptadas al nivel del desarrollador
- **An√°lisis de flujo de datos** y control de programa
- **Detecci√≥n de patrones** y arquitecturas utilizadas
- **Business logic** extra√≠do y explicado claramente
- **Diagramas autom√°ticos** para visualizar la l√≥gica
- **Ejemplos interactivos** para facilitar comprensi√≥n
- **Onboarding assistance** para nuevos desarrolladores
- **Code review insights** para mejorar calidad
- **Documentation generation** autom√°tica

## Usage

```
/explain-code [archivo] [--nivel] [--format] [--foco] [--diagrama]
```

### Par√°metros

- `archivo`: Archivo espec√≠fico a explicar
- `--nivel`: Nivel de audiencia (beginner, intermediate, expert, mixed-team)
- `--format`: Formato de salida (detailed, summary, interactive, documentation)
- `--foco`: Aspecto espec√≠fico (logic, architecture, performance, security, patterns)
- `--diagrama`: Generar diagramas (flowchart, sequence, architecture, data-flow)
- `--contexto`: Contexto del proyecto (startup, enterprise, legacy, educational)
- `--language`: Idioma de la explicaci√≥n (spanish, english, french, etc.)
- `--examples`: Incluir ejemplos pr√°cticos

### Examples

```
/explain-code src/utils/dataProcessor.js
/explain-code --nivel=beginner --format=interactive --diagrama=flowchart
/explain-code components/UserAuth.tsx --foco=security --nivel=expert
/explain-code api/payment.js --format=documentation --contexto=enterprise
/explain-code --foco=architecture --diagrama=sequence --nivel=mixed-team
/explain-code legacy/billing.js --nivel=intermediate --examples=true
```

## Tipos de Explicaciones

### üìö Explicaci√≥n Detallada para Principiantes
```javascript
// C√≥digo original
const processUserData = async (users) => {
  return await Promise.all(
    users
      .filter(user => user.isActive && user.lastLogin > Date.now() - 30 * 24 * 60 * 60 * 1000)
      .map(async user => {
        const profile = await fetchUserProfile(user.id);
        const preferences = await getUserPreferences(user.id);
        
        return {
          ...user,
          profile: profile?.data || {},
          preferences: preferences?.settings || {},
          score: calculateUserScore(user, profile?.data)
        };
      })
  );
};

// ‚ú® EXPLICACI√ìN GENERADA AUTOM√ÅTICAMENTE:

üìö EXPLICACI√ìN PASO A PASO:
==========================

üéØ PROP√ìSITO DE LA FUNCI√ìN:
Esta funci√≥n procesa una lista de usuarios para crear un resumen enriquecido
de cada usuario activo que haya iniciado sesi√≥n recientemente.

üìã QU√â HACE LA FUNCI√ìN:

1Ô∏è‚É£ FILTRADO DE USUARIOS ACTIVOS:
   ‚Ä¢ Toma una lista de usuarios como entrada
   ‚Ä¢ Filtra solo usuarios que est√©n "activos" (user.isActive = true)
   ‚Ä¢ Adem√°s filtra usuarios que hayan hecho login en los √∫ltimos 30 d√≠as
   
   üí° C√ÅLCULO DE 30 D√çAS:
   30 * 24 * 60 * 60 * 1000 = 30 d√≠as en milisegundos
   Date.now() - 30 d√≠as = timestamp de hace exactamente 30 d√≠as

2Ô∏è‚É£ ENRIQUECIMIENTO DE DATOS:
   Para cada usuario que pasa el filtro:
   ‚Ä¢ Obtiene su perfil completo del servidor (fetchUserProfile)
   ‚Ä¢ Obtiene sus preferencias de usuario (getUserPreferences)
   ‚Ä¢ Ambas operaciones son as√≠ncronas (await)

3Ô∏è‚É£ CREACI√ìN DEL OBJETO FINAL:
   Combina la informaci√≥n original del usuario con:
   ‚Ä¢ Datos del perfil (o objeto vac√≠o {} si no hay datos)
   ‚Ä¢ Preferencias del usuario (o objeto vac√≠o {} si no hay configuraciones)
   ‚Ä¢ Un score calculado basado en el usuario y su perfil

4Ô∏è‚É£ PROCESAMIENTO PARALELO:
   ‚Ä¢ Promise.all() ejecuta todas las operaciones async en paralelo
   ‚Ä¢ Esto es MUY importante para performance: en lugar de esperar cada
     usuario uno por uno, procesa all simult√°neamente

üîß CONCEPTOS T√âCNICOS EXPLICADOS:

üì¶ SPREAD OPERATOR (...user):
   Copia todas las propiedades del objeto 'user' al nuevo objeto.
   Es como decir "incluye todo lo que ya ten√≠a el usuario original"

üõ°Ô∏è OPTIONAL CHAINING (?.):
   profile?.data significa "si profile existe, dame profile.data, 
   si no existe, devuelve undefined"

üîÑ NULLISH COALESCING (||):
   profile?.data || {} significa "usa profile.data si existe,
   si no usa un objeto vac√≠o {}"

‚ö° ASYNC/AWAIT:
   Permite escribir c√≥digo as√≠ncrono que se lee como s√≠ncrono.
   Cada 'await' pausa la funci√≥n hasta que la promesa se resuelve.

üöÄ PROMISE.ALL():
   Ejecuta m√∫ltiples promesas en paralelo y espera a que todas terminen.
   Si tienes 100 usuarios, las 200 llamadas API (profile + preferences)
   se ejecutan al mismo tiempo en lugar de secuencialmente.

üí° CASOS DE USO T√çPICOS:
‚Ä¢ Dashboard que muestra usuarios activos con informaci√≥n completa
‚Ä¢ Sistema de recomendaciones basado en scores de usuario
‚Ä¢ Reportes de actividad de usuarios para administradores
‚Ä¢ Sistemas de gamificaci√≥n que requieren datos enriquecidos

‚ö†Ô∏è CONSIDERACIONES IMPORTANTES:
‚Ä¢ Esta funci√≥n puede hacer muchas llamadas API simult√°neas
‚Ä¢ Considerar rate limiting si la lista de usuarios es muy grande
‚Ä¢ Manejar errores: ¬øqu√© pasa si fetchUserProfile falla?
‚Ä¢ El c√°lculo de 30 d√≠as asume timestamps en milisegundos

üéØ MEJORAS SUGERIDAS:
1. Agregar manejo de errores con try/catch
2. Implementar batch fetching para reducir llamadas API
3. Agregar logging para debugging
4. Considerar cache para perfiles que no cambian frecuentemente
```

### üèóÔ∏è Explicaci√≥n Arquitectural para Equipos
```javascript
// C√≥digo original: Sistema de autenticaci√≥n
class AuthenticationService {
  constructor(tokenService, userRepository, auditLogger) {
    this.tokenService = tokenService;
    this.userRepository = userRepository;
    this.auditLogger = auditLogger;
  }

  async authenticate(credentials) {
    const user = await this.userRepository.findByEmail(credentials.email);
    
    if (!user || !await this.validatePassword(credentials.password, user.hashedPassword)) {
      await this.auditLogger.logFailedAttempt(credentials.email);
      throw new AuthenticationError('Invalid credentials');
    }

    const token = await this.tokenService.generateToken(user);
    await this.auditLogger.logSuccessfulLogin(user);
    
    return { user, token };
  }
}

// ‚ú® EXPLICACI√ìN ARQUITECTURAL GENERADA:

üèóÔ∏è AN√ÅLISIS ARQUITECTURAL:
==========================

üìê PATR√ìN DE DISE√ëO IDENTIFICADO:
‚Ä¢ DEPENDENCY INJECTION: La clase recibe sus dependencias en el constructor
‚Ä¢ SERVICE LAYER: Encapsula l√≥gica de negocio de autenticaci√≥n
‚Ä¢ REPOSITORY PATTERN: Abstrae el acceso a datos de usuarios
‚Ä¢ SINGLE RESPONSIBILITY: Solo se encarga de autenticaci√≥n

üîó DIAGRAMA DE DEPENDENCIAS:
```
AuthenticationService
‚îú‚îÄ‚îÄ TokenService (Generaci√≥n/validaci√≥n de tokens)
‚îú‚îÄ‚îÄ UserRepository (Acceso a datos de usuarios)
‚îî‚îÄ‚îÄ AuditLogger (Logging de seguridad)
```

üéØ VENTAJAS DE ESTA ARQUITECTURA:

1Ô∏è‚É£ TESTABILIDAD:
   ‚Ä¢ F√°cil hacer unit tests con mocks de las dependencias
   ‚Ä¢ Cada servicio se puede testear independientemente

2Ô∏è‚É£ FLEXIBILIDAD:
   ‚Ä¢ Se puede cambiar la implementaci√≥n de tokens (JWT ‚Üí OAuth)
   ‚Ä¢ Se puede cambiar la base de datos sin afectar la l√≥gica
   ‚Ä¢ Se puede cambiar el sistema de logging independientemente

3Ô∏è‚É£ SEPARATION OF CONCERNS:
   ‚Ä¢ AuthService: Solo l√≥gica de autenticaci√≥n
   ‚Ä¢ TokenService: Solo manejo de tokens
   ‚Ä¢ UserRepository: Solo acceso a datos
   ‚Ä¢ AuditLogger: Solo logging de seguridad

üîê FLUJO DE SEGURIDAD:

1. Validaci√≥n de credenciales
2. Logging de intentos fallidos (security audit)
3. Generaci√≥n de token seguro
4. Logging de logins exitosos (compliance)
5. Retorno de informaci√≥n autorizada

üöÄ ESCALABILIDAD:
‚Ä¢ Cada servicio puede escalar independientemente
‚Ä¢ Se puede implementar cache en UserRepository
‚Ä¢ Se puede hacer el AuditLogger as√≠ncrono
‚Ä¢ TokenService puede usar clusters para performance

üìä PATRONES ENTERPRISE APLICADOS:
‚Ä¢ ‚úÖ Dependency Injection
‚Ä¢ ‚úÖ Repository Pattern  
‚Ä¢ ‚úÖ Service Layer
‚Ä¢ ‚úÖ Error Handling Strategy
‚Ä¢ ‚úÖ Audit Trail Pattern
‚Ä¢ ‚úÖ Secure Token Generation

üéØ USO EN ARQUITECTURA HEXAGONAL:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Authentication    ‚îÇ ‚Üê Application Service
‚îÇ      Service        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ     ‚îÇ     ‚îÇ
    ‚ñº     ‚ñº     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇToken ‚îÇ ‚îÇUser  ‚îÇ ‚îÇAudit ‚îÇ ‚Üê Domain Services
‚îÇSvc   ‚îÇ ‚îÇRepo  ‚îÇ ‚îÇLog   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

üí° RECOMENDACIONES DE EQUIPO:
‚Ä¢ Ideal para equipos que valoran clean architecture
‚Ä¢ Perfecta para aplicaciones enterprise que necesitan audit trails
‚Ä¢ Facilita onboarding de nuevos desarrolladores
‚Ä¢ Permite desarrollo paralelo de diferentes servicios
```

### üé® Explicaci√≥n Visual con Diagramas
```javascript
// C√≥digo: Sistema de payment processing
const processPayment = async (order, paymentMethod) => {
  const validation = await validateOrder(order);
  if (!validation.isValid) throw new Error(validation.error);
  
  const payment = await chargePayment(paymentMethod, order.total);
  if (payment.status === 'failed') {
    await logFailedPayment(order, payment);
    throw new PaymentError(payment.errorMessage);
  }
  
  const updatedOrder = await updateOrderStatus(order.id, 'paid');
  await sendConfirmationEmail(order.customer.email, updatedOrder);
  await logSuccessfulPayment(order, payment);
  
  return { order: updatedOrder, payment };
};

// ‚ú® DIAGRAMA AUTOM√ÅTICO GENERADO:

üé® DIAGRAMA DE FLUJO GENERADO:
=============================

```mermaid
flowchart TD
    A[Start: processPayment] --> B[validateOrder]
    B --> C{validation.isValid?}
    C -->|No| D[Throw Error]
    C -->|Yes| E[chargePayment]
    E --> F{payment.status === 'failed'?}
    F -->|Yes| G[logFailedPayment]
    G --> H[Throw PaymentError]
    F -->|No| I[updateOrderStatus to 'paid']
    I --> J[sendConfirmationEmail]
    J --> K[logSuccessfulPayment]
    K --> L[Return result]
    
    style A fill:#e1f5fe
    style D fill:#ffebee
    style H fill:#ffebee
    style L fill:#e8f5e8
```

üìä DIAGRAMA DE SECUENCIA:
========================

```mermaid
sequenceDiagram
    participant Client
    participant PaymentService
    participant OrderValidator
    participant PaymentGateway
    participant Database
    participant EmailService
    participant Logger

    Client->>PaymentService: processPayment(order, paymentMethod)
    PaymentService->>OrderValidator: validateOrder(order)
    OrderValidator-->>PaymentService: validation result
    
    alt validation failed
        PaymentService-->>Client: throw Error
    else validation passed
        PaymentService->>PaymentGateway: chargePayment(method, total)
        PaymentGateway-->>PaymentService: payment result
        
        alt payment failed
            PaymentService->>Logger: logFailedPayment()
            PaymentService-->>Client: throw PaymentError
        else payment success
            PaymentService->>Database: updateOrderStatus('paid')
            PaymentService->>EmailService: sendConfirmationEmail()
            PaymentService->>Logger: logSuccessfulPayment()
            PaymentService-->>Client: return {order, payment}
        end
    end
```

üîç PUNTOS CR√çTICOS IDENTIFICADOS:
================================

üö® ERROR HANDLING:
‚Ä¢ 2 puntos de falla principales: validaci√≥n y payment
‚Ä¢ Logging diferenciado para troubleshooting
‚Ä¢ Error types espec√≠ficos para diferentes fallas

‚ö° PERFORMANCE CONSIDERATIONS:
‚Ä¢ updateOrderStatus y sendConfirmationEmail podr√≠an ser paralelos
‚Ä¢ logSuccessfulPayment podr√≠a ser as√≠ncrono (fire-and-forget)

üîê SECURITY ASPECTS:
‚Ä¢ Validaci√≥n obligatoria antes de procesar pago
‚Ä¢ Logging completo para audit trail
‚Ä¢ Error messages no exponen informaci√≥n sensible

üí∞ BUSINESS LOGIC:
‚Ä¢ Transaccional: order status solo se actualiza tras pago exitoso
‚Ä¢ Email confirmation es parte del flujo cr√≠tico
‚Ä¢ Logging para compliance y analytics
```

### üéì Explicaci√≥n Educativa Interactiva
```javascript
// C√≥digo: Algoritmo de b√∫squeda binary search
const binarySearch = (arr, target) => {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  
  return -1;
};

// ‚ú® EXPLICACI√ìN EDUCATIVA INTERACTIVA:

üéì TUTORIAL INTERACTIVO: BINARY SEARCH
======================================

üìö ¬øQU√â ES BINARY SEARCH?
Es un algoritmo de b√∫squeda ultra-eficiente que funciona 
"dividiendo y conquistando" un array ordenado.

üéØ ANALOG√çA DEL MUNDO REAL:
Imagina que buscas una palabra en un diccionario:
1. Abres por la mitad
2. Si la palabra est√° antes, buscas en la mitad izquierda
3. Si est√° despu√©s, buscas en la mitad derecha
4. Repites hasta encontrarla

‚ö° ¬øPOR QU√â ES TAN R√ÅPIDO?
‚Ä¢ Array de 1,000 elementos: m√°ximo 10 comparaciones
‚Ä¢ Array de 1,000,000 elementos: m√°ximo 20 comparaciones
‚Ä¢ Complejidad: O(log n) vs O(n) de b√∫squeda lineal

üîç PASO A PASO CON EJEMPLO:
===========================
Busquemos el n√∫mero 7 en [1, 3, 5, 7, 9, 11, 13, 15]

üìç ITERACI√ìN 1:
   left=0, right=7, mid=3
   arr[3] = 7 ‚Üê ¬°ENCONTRADO!
   
üéâ RESULTADO: √≠ndice 3

üîÑ EJEMPLO M√ÅS COMPLEJO:
Busquemos el n√∫mero 11 en [1, 3, 5, 7, 9, 11, 13, 15]

üìç ITERACI√ìN 1:
   left=0, right=7, mid=3
   arr[3] = 7 < 11 ‚Üí buscar derecha
   left = 4

üìç ITERACI√ìN 2:
   left=4, right=7, mid=5
   arr[5] = 11 ‚Üê ¬°ENCONTRADO!
   
üéâ RESULTADO: √≠ndice 5

üß† CONCEPTOS CLAVE EXPLICADOS:

üéØ INVARIANTE DEL ALGORITMO:
"Si el target existe en el array, siempre estar√° entre left y right"

üìê C√ÅLCULO DEL PUNTO medium:
Math.floor((left + right) / 2) asegura que mid sea entero
¬øPor qu√© Math.floor? Para evitar √≠ndices decimales

‚öñÔ∏è DECISI√ìN L√ìGICA:
‚Ä¢ arr[mid] === target ‚Üí Encontrado ‚úÖ
‚Ä¢ arr[mid] < target ‚Üí target est√° a la derecha ‚Üí
‚Ä¢ arr[mid] > target ‚Üí target est√° a la izquierda ‚Üê

üîÑ CONDICI√ìN DE PARADA:
left > right significa que hemos agotado todas las posibilidades
El target no existe en el array ‚Üí return -1

‚ö†Ô∏è PREREQUISITO CR√çTICO:
¬°EL ARRAY DEBE ESTAR ORDENADO!
Si no est√° ordenado, el algoritmo NO funcionar√° correctamente.

üöÄ CASOS DE USO REALES:
‚Ä¢ B√∫squeda en bases de datos indexadas
‚Ä¢ Autocompletado en b√∫squeda web
‚Ä¢ Sistemas de recomendaci√≥n
‚Ä¢ Algoritmos de machine learning
‚Ä¢ Cualquier b√∫squeda en datos ordenados

üé™ EXPERIMENTO INTERACTIVO:
Prueba modificar el target y ver c√≥mo cambia el n√∫mero de iteraciones:
‚Ä¢ Target 1: 1 iteraci√≥n (peor caso izquierda)
‚Ä¢ Target 15: 2 iteraciones (peor caso derecha)  
‚Ä¢ Target 8: 4 iteraciones (no existe)

üí° OPTIMIZACIONES AVANZADAS:
‚Ä¢ Interpolation search para datos uniformemente distribuidos
‚Ä¢ Exponential search para arrays muy grandes
‚Ä¢ Ternary search para encontrar m√°ximos/m√≠nimos
```

## Configuraci√≥n

`.claude/explain-code-config.json`:

```json
{
  "audience": {
    "beginner": {
      "includeBasicConcepts": true,
      "useAnalogies": true,
      "stepByStepBreakdown": true,
      "avoidJargon": true,
      "includeExamples": true
    },
    "intermediate": {
      "assumeBasicKnowledge": true,
      "focusOnPatterns": true,
      "includePerformanceNotes": true,
      "showAlternatives": true
    },
    "expert": {
      "technicalDepth": "high",
      "focusOnArchitecture": true,
      "includeOptimizations": true,
      "discussTradeoffs": true,
      "showAdvancedPatterns": true
    },
    "mixedTeam": {
      "multiLevelExplanation": true,
      "includeGlossary": true,
      "progressiveDisclosure": true
    }
  },
  "formats": {
    "detailed": {
      "includeComments": true,
      "showDataFlow": true,
      "explainEachLine": true,
      "includeContext": true
    },
    "summary": {
      "keyPointsOnly": true,
      "bulletFormat": true,
      "highlightImportant": true
    },
    "interactive": {
      "includeExamples": true,
      "showVariations": true,
      "includeExperiments": true,
      "stepThroughExecution": true
    },
    "documentation": {
      "formhighne": true,
      "includeAPISignatures": true,
      "showUsageExamples": true,
      "includeBestPractices": true
    }
  },
  "diagrams": {
    "flowchart": {
      "tool": "mermaid",
      "showDecisionPoints": true,
      "includeErrorPaths": true,
      "colorCoding": true
    },
    "sequence": {
      "tool": "mermaid",
      "showAsyncOperations": true,
      "includeTimings": false,
      "showErrorScenarios": true
    },
    "architecture": {
      "tool": "mermaid",
      "showLayers": true,
      "includeDependencies": true,
      "showDataFlow": true
    },
    "dataFlow": {
      "tool": "mermaid",
      "showTransformations": true,
      "includeValidation": true,
      "showStoragePoints": true
    }
  },
  "focus": {
    "logic": {
      "explainAlgorithms": true,
      "showComplexity": true,
      "includeEdgeCases": true
    },
    "architecture": {
      "showPatterns": true,
      "explainStructure": true,
      "discussScalability": true
    },
    "performance": {
      "identifyBottlenecks": true,
      "suggestOptimizations": true,
      "showBenchmarks": false
    },
    "security": {
      "identifyVulnerabilities": true,
      "explainMitigations": true,
      "showBestPractices": true
    }
  },
  "languages": {
    "spanish": {
      "useSpanishTerms": true,
      "includeEnglishEquivalents": true,
      "culturalContext": "latin-america"
    },
    "english": {
      "variant": "us",
      "technicalStyle": "modern"
    }
  }
}
```

## Salida del Comando

### An√°lisis de C√≥digo
```
üß† CLAUDE POWER - CODE EXPLANATION ANALYSIS
===========================================

üìÅ ARCHIVO ANALIZADO:
src/services/PaymentProcessor.js (234 l√≠neas)

üîç AN√ÅLISIS AUTOM√ÅTICO:
‚Ä¢ Complejidad: Media (7.2/10)
‚Ä¢ Patrones detectados: Factory, Observer, Strategy
‚Ä¢ Conceptos clave: Async programming, Error handling, State machine
‚Ä¢ Business logic: Payment processing workflow
‚Ä¢ Audiencia sugerida: Intermediate developers

üìä ELEMENTOS IDENTIFICADOS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Elemento            ‚îÇ Count   ‚îÇ Complejidad         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Functions           ‚îÇ   12    ‚îÇ Media               ‚îÇ
‚îÇ Classes             ‚îÇ    3    ‚îÇ Alta                ‚îÇ
‚îÇ Async Operations    ‚îÇ    8    ‚îÇ Media               ‚îÇ
‚îÇ Error Handlers      ‚îÇ    6    ‚îÇ Baja                ‚îÇ
‚îÇ Business Rules      ‚îÇ   15    ‚îÇ Alta                ‚îÇ
‚îÇ Design Patterns     ‚îÇ    3    ‚îÇ Media               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üéØ ASPECTOS A EXPLICAR:
‚Ä¢ Payment state machine workflow
‚Ä¢ Error handling strategy
‚Ä¢ Async operation coordination
‚Ä¢ Security considerations
‚Ä¢ Integration patterns
‚Ä¢ Testing approaches

‚è±Ô∏è TIEMPO ESTIMADO DE LECTURA: 12-15 minutos
üë• AUDIENCIA √ìPTIMA: Intermediate to Senior developers
```

### Explicaci√≥n Generada
```
üìö EXPLICACI√ìN COMPLETA GENERADA:
================================

üìÑ DOCUMENTO CREADO:
‚Ä¢ src/services/PaymentProcessor.md (1,247 palabras)
‚Ä¢ Diagramas incluidos: 3 (flowchart, sequence, architecture)
‚Ä¢ Ejemplos pr√°cticos: 8
‚Ä¢ Conceptos explicados: 15

üéØ SECCIONES INCLUIDAS:
‚úÖ Prop√≥sito y responsabilidades
‚úÖ Arquitectura y patrones utilizados
‚úÖ Flujo de datos paso a paso
‚úÖ Manejo de errores y edge cases
‚úÖ Consideraciones de seguridad
‚úÖ Ejemplos de uso pr√°ctico
‚úÖ Testing strategies
‚úÖ Posibles mejoras y optimizaciones

üìä M√âTRICAS DE CALIDAD:
‚Ä¢ Claridad: 9.2/10
‚Ä¢ Completitud: 9.0/10
‚Ä¢ Utilidad para onboarding: 9.5/10
‚Ä¢ Precisi√≥n t√©cnica: 9.8/10

üéì FEEDBACK EDUCATIVO:
‚Ä¢ Ideal para desarrolladores mid-level
‚Ä¢ Contiene conceptos transferibles a otros proyectos
‚Ä¢ Incluye best practices y anti-patterns
‚Ä¢ Facilita code reviews futuros
```

### Diagramas Interactivos
```
üé® DIAGRAMAS GENERADOS AUTOM√ÅTICAMENTE:
======================================

üìä FLOWCHART PRINCIPAL:
‚Ä¢ Muestra el flujo completo de payment processing
‚Ä¢ Incluye decision points y error paths
‚Ä¢ Color-coded por tipo de operaci√≥n
‚Ä¢ Enlaces interactivos a explicaciones detalladas

üîÑ SEQUENCE DIAGRAM:
‚Ä¢ Interacciones entre servicios
‚Ä¢ Timeouts y retries visualizados
‚Ä¢ Async operations claramente marcadas
‚Ä¢ Error scenarios incluidos

üèóÔ∏è ARCHITECTURE DIAGRAM:
‚Ä¢ Dependencias entre componentes
‚Ä¢ Data flow entre capas
‚Ä¢ External service integrations
‚Ä¢ Security boundaries marcados

üíæ ARCHIVOS GENERADOS:
‚Ä¢ payment-processor-flowchart.svg
‚Ä¢ payment-processor-sequence.svg  
‚Ä¢ payment-processor-architecture.svg
‚Ä¢ payment-processor-explanation.md
```

## Integraci√≥n con Herramientas

### VS Code Extension
```json
{
  "commands": [
    {
      "command": "claude-power.explainCode",
      "title": "Explain This Code",
      "category": "Claude Power"
    },
    {
      "command": "claude-power.explainFunction",
      "title": "Explain Current Function",
      "category": "Claude Power"
    }
  ],
  "menus": {
    "editor/context": [
      {
        "command": "claude-power.explainCode",
        "when": "editorHasSelection",
        "group": "claude-power"
      }
    ]
  },
  "keybindings": [
    {
      "command": "claude-power.explainCode",
      "key": "ctrl+shift+e",
      "when": "editorTextFocus"
    }
  ]
}
```

### GitHub Integration
```yaml
name: Auto Documentation

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  explain-changes:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
        
      - name: Get changed files
        id: changes
        run: |
          git diff --name-only ${{ github.event.before }} ${{ github.sha }} > changed_files.txt
          
      - name: Explain code changes
        run: |
          while read file; do
            if [[ $file == *.js || $file == *.ts || $file == *.tsx ]]; then
              npx claude-power explain-code "$file" \
                --nivel=mixed-team \
                --format=summary \
                --output=markdown > "explanations/${file}.md"
            fi
          done < changed_files.txt
          
      - name: Comment PR with explanations
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const explanations = [];
            const explanationsDir = 'explanations';
            
            if (fs.existsSync(explanationsDir)) {
              const files = fs.readdirSync(explanationsDir);
              
              for (const file of files) {
                const content = fs.readFileSync(path.join(explanationsDir, file), 'utf8');
                const originalFile = file.replace('.md', '');
                
                explanations.push(`
                ### üìö ${originalFile}
                
                ${content}
                `);
              }
            }
            
            if (explanations.length > 0) {
              const comment = `
              ## üß† Code Explanation for Changes
              
              ${explanations.join('\n---\n')}
              
              *Generated by Claude Power Explain Code*
              `;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
```

---

*Parte del ecosistema **Claude Power** - C√≥digo explicado inteligentemente* üß†üöÄ 
